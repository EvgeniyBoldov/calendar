# RBAC и аутентификация: дизайн

## 1. Модель пользователей и ролей

### 1.1. Сущность пользователя

Система предполагает **одну роль на пользователя**.

Предлагаемая структура таблицы `users` (логическая модель):

- `id: uuid` — первичный ключ.
- `login: str` — доменный логин / UID пользователя.
- `email: str` — почта пользователя (для уведомлений и идентификации).
- `full_name: str | None` — ФИО / отображаемое имя.
- `role: enum('ADMIN', 'EXPERT', 'TRP', 'ENGINEER')` — роль пользователя.
- `is_active: bool` — флаг активности (для блокировки учётки).
- `password_hash: str | None` — хэш пароля для локального/MVP-входа.
- `created_at: datetime`.
- `updated_at: datetime`.

Пароли по e‑mail **не рассылаются**. В MVP допускается локальный логин/пароль, в продакшене планируется переход на **LDAP**:

- `login` и `email` берутся из LDAP.
- Админ в системе только вешает и меняет `role`.
- Проверка пароля может быть реализована как отдельный провайдер (локальный или LDAP), не влияющий на остальную схему токенов и прав.


## 2. Роли и права (RBAC)

### 2.1. Роли

Поддерживаются 4 типа пользователей:

1. **ADMIN** — администратор системы.
2. **EXPERT** — эксперт по планированию (почти админ по доменной области планирования).
3. **TRP** — заказчик работ (ТРП).
4. **ENGINEER** — инженер-исполнитель.

### 2.2. Обозначения

- **Work** — сущность работы.
- **Автор работы** — `work.author_id == user.id`.
- **"Свои работы" ТРП** — работы, которые он создал или где он указан автором.

### 2.3. Матрица прав

#### ADMIN

- **Видимость**
  - Видит **всё**: все работы, все инженеры, все ДЦ, все пользователи.

- **Работы (Work)**
  - Создавать / читать / обновлять / удалять **любые** работы.
  - Полный доступ к статусам работ.
  - Полный доступ к операциям планирования:
    - ручное назначение / перенос,
    - авто‑назначение чанков и работ,
    - любые операции с planning‑sessions (создание, применение, отмена, удаление),
    - подтверждение планов, отмена назначений и т.п.

- **Инженеры и ДЦ**
  - CRUD (создание, редактирование, удаление) инженеров.
  - CRUD по ДЦ и другим справочникам.

- **Пользователи**
  - CRUD пользователей.
  - Смена ролей (`role`).
  - Блокировка/разблокировка (`is_active`).

---

#### EXPERT (Эксперт)

- **Видимость**
  - Видит **все работы**.
  - Видит **всех инженеров**.
  - Видит **все ДЦ**.

- **Работы (Work)**
  - Может создавать / редактировать / удалять **любые** работы.
  - Может **менять автора** работы.
  - Имеет полный доступ к **планированию**:
    - suggest‑слоты для чанков,
    - авто‑назначение отдельно взятого чанка,
    - авто‑назначение всей работы (по выбранной стратегии),
    - операции с planning‑sessions (создание, применение, отмена).

- **Инженеры и ДЦ**
  - Полный CRUD инженеров.
  - Полный CRUD ДЦ.

- **Пользователи**
  - Не видит страницу управления пользователями.
  - Не может менять роли пользователей — это только ADMIN.

---

#### TRP (Заказчик)

- **Видимость**
  - В списке работ видит **только свои работы**:
    - те, которые он создал,
    - те, где он указан автором.
  - При открытии своей работы видит **полный план** этой работы:
    - шаги, чанки, задачи, статусы.
  - Видит **все ДЦ**.
  - Видит инженеров и их загрузку, а также работы в ДЦ **вообще**, для оценки загрузки (read‑only):
    - расписание инженеров,
    - занятость по ДЦ.

- **Работы (Work)**
  - Может **создавать** работы (становится их автором).
  - Может **редактировать** и обновлять **только свои** работы:
    - менять описание и ключевые поля работы,
    - составлять/редактировать план работ,
    - загружать план работ из файла,
    - собирать чанки и управлять структурой плана.
  - **Не может назначать слот** на чанк:
    - ни ручное присвоение слота,
    - ни авто‑назначение чанков/работ.
    - Все действия по назначению слотов — только для EXPERT/ADMIN.

- **Инженеры и ДЦ**
  - Только просмотр (read‑only), без права изменения.

---

#### ENGINEER (Инженер)

- **Видимость**
  - "Личный кабинет" инженера:
    - свои назначенные чанки,
    - свои работы в календаре,
    - своё расписание и загрузка.
  - Для любой работы, где у инженера есть хотя бы один чанк:
    - видит **полный план работы** (все чанки и задачи в них).

- **Работы и задачи**
  - Может **отмечать выполнение задач** в чанках, в том числе:
    - задачи в своём чанке,
    - задачи в других чанках этой же работы (для коррекции при ошибке планирования).
  - Может **добавлять новые задачи** в план **в свой чанк** (если забыли шаг).
  - Не может:
    - создавать или удалять работы,
    - менять статусы работ,
    - выполнять операции планирования (назначение слотов, авто‑assign, planning‑sessions).


## 3. Аутентификация и токены

### 3.1. Общий подход

Используется схема **access + refresh токены в HttpOnly Secure куках**:

- Access‑токен — короткоживущий, используется для авторизации запросов.
- Refresh‑токен — более долгоживущий, позволяет прозрачно обновлять access‑токен без повторного логина.
- Куки недоступны из JS (`HttpOnly`), что уменьшает риск кражи токена через XSS.

### 3.2. Access‑токен

- Формат: JWT.
- Срок жизни: **15 минут** (можно будет уточнить конфигом).
- Поля (payload):
  - `sub` — идентификатор пользователя (`user_id`).
  - `role` — текущая роль (`ADMIN` / `EXPERT` / `TRP` / `ENGINEER`).
  - `login` и/или `email` — для удобства.
  - `iat` — время выпуска.
  - `exp` — время истечения.

### 3.3. Refresh‑токен

- Формат: JWT.
- Срок жизни: **7 дней**.
- Поля:
  - `sub` — идентификатор пользователя.
  - `jti` — идентификатор токена (для хранения в БД и отзывов).
  - `iat`, `exp`.

- Таблица `refresh_tokens` (логическая модель):
  - `id` / `jti` — уникальный ID токена.
  - `user_id` — к кому привязан.
  - `revoked: bool` — отозван ли токен.
  - `expires_at: datetime`.
  - `created_at: datetime`.

### 3.4. Куки

Используются две отдельные куки:

- `access_token`
  - `HttpOnly`, `Secure`, `SameSite=Lax`.
  - TTL ~= срок жизни access‑токена.

- `refresh_token`
  - `HttpOnly`, `Secure`, `SameSite=Lax` или `Strict` (подберётся под фронт + nginx).
  - TTL = 7 дней.

JS не читает токены напрямую. Бэкенд достаёт токены из кук и проверяет их.

### 3.5. Эндпоинты аутентификации

1. `POST /api/auth/login`
   - Вход: `{ login, password }`.
   - Проверка пароля:
     - В MVP — по `password_hash` в БД.
     - В продакшене — возможен LDAP-провайдер, который проверяет логин/пароль во внешней системе.
   - При успехе:
     - создаёт access + refresh токены,
     - устанавливает куки `access_token`, `refresh_token`,
     - возвращает JSON с данными пользователя (`id, role, email, full_name`).

2. `POST /api/auth/refresh`
   - Читает `refresh_token` из куки.
   - Проверяет JWT + статус в `refresh_tokens` (не отозван, не истёк).
   - Выпускает новый access‑токен (и при необходимости новый refresh‑токен с ротацией).
   - Обновляет соответствующие куки.

3. `POST /api/auth/logout`
   - Читает `refresh_token` из куки.
   - Помечает его как `revoked` в таблице `refresh_tokens`.
   - Сбрасывает/очищает обе куки (access + refresh).

4. `GET /api/auth/me`
   - По access‑токену в куке возвращает информацию о текущем пользователе.

### 3.6. Авторизация в коде

- Dependency `get_current_user`:
  - Читает и проверяет access‑токен.
  - Загружает пользователя из БД.
  - Проверяет `is_active`.

- Дополнительные зависимости/хелперы:
  - `require_role('ADMIN')`.
  - `require_any_role(['ADMIN', 'EXPERT'])`.
  - Проверки на уровне запросов к данным:
    - для TRP — фильтрация работ по `author_id = current_user.id`;
    - для ENGINEER — фильтрация по работам, где есть назначенные на него чанки.


## 4. Login‑флоу и фронтенд

### 4.1. Страница логина

- Отдельный `LoginView` на фронте.
- Поля:
  - `login` — доменный логин.
  - `password` — пароль.
- При сабмите:
  - `POST /api/auth/login`.
  - При успехе бэкенд ставит куки.
  - Фронтенд получает JSON с user и сохраняет его в своём сторе.

### 4.2. Редиректы после логина

- Для ролей:
  - **ENGINEER** → "личный кабинет" инженера (dashboard / календарь инженера).
  - **TRP** / **EXPERT** / **ADMIN** → страница работ (основной экран со списком/календарём работ).

Роутер на фронте:

- Защищённые роуты требуют наличие `currentUser`.
- Интерфейс (меню, кнопки) адаптируется под `role`:
  - Инженеру не показываются пункты и действия по планированию работ.
  - TRP не видит управление пользователями и ролями.
  - EXPERT не видит управление пользователями, но видит и может менять инженеров/ДЦ и планирование.
  - ADMIN видит полный набор разделов.


## 5. Nginx и self-signed TLS

Для локального/MVP-стенда планируется nginx как фронтовой прокси.

### 5.1. Схема

- `nginx` в `docker-compose` как отдельный сервис.
- HTTPS-терминация на nginx:
  - self-signed сертификат для `localhost` или условного хоста (например, `calendar.local`).
- Проксирование:
  - `https://<host>/` → фронтенд (SPA).
  - `https://<host>/api/` → backend (FastAPI).

### 5.2. Сертификат

- Генерация самоподписанного сертификата для выбранного локального хоста.
- Монтирование сертификата и ключа в контейнер nginx.
- В браузере потребуется однократно подтвердить доверие к self-signed сертификату.

### 5.3. Заголовки и безопасность

- Корректные прокси-заголовки:
  - `X-Forwarded-Proto`, `X-Real-IP`, `X-Forwarded-For`.
- `Strict-Transport-Security` (в dev-режиме можно сделать щадящим).
- Учёт `SameSite` и `Secure` для кук при работе за nginx и HTTPS.


## 6. Дальнейшие шаги и TODO

1. **Реализовать модель `users` и enum ролей** в backend:
   - таблица `users` и enum `UserRole`.
   - миграции.

2. **Реализовать таблицу `refresh_tokens`** и логику хранения/ревокации.

3. **Реализовать auth-эндпоинты** `/api/auth/login`, `/api/auth/refresh`, `/api/auth/logout`, `/api/auth/me`.

4. **Добавить зависимости авторизации и ролей** в backend:
   - `get_current_user`, `require_role`, `require_any_role`.
   - Ограничения на эндпоинтах планирования, CRUD работ, инженеров, ДЦ и пользователей.

5. **Фронтенд**:
   - Страница логина.
   - Хранение текущего пользователя в сторе.
   - Редиректы по ролям после логина.
   - Скрытие/блокировка UI-действий в зависимости от роли.

6. **Nginx + TLS**:
   - Добавить nginx-сервис в `docker-compose`.
   - Сгенерировать self-signed сертификат для локального домена.
   - Настроить проксирование фронта и бекенда через HTTPS.

7. **LDAP (отдельный этап)**:
   - Описать интерфейс провайдера аутентификации (Local vs LDAP).
   - Реализовать LDAP-проверку логина/пароля без изменения остальной схемы токенов.
